<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="RANS : " />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="javascripts/prettify/prettify.css"/>
	<script type="text/javascript" src="javascripts/prettify/prettify.js"></script>

    <title>RANS</title>
  </head>

  <body onload="prettyPrint()">

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/sinya8282/RANS">View on GitHub</a>

          <h1 id="project_title">RANS : More advanced usage of regular expressions.</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/sinya8282/RANS/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/sinya8282/RANS/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
		<pre><code class="prettyprint lang-sh">36858570256415121325678741627137383137485170961739808804878081</code></pre>
		<p>Can you guess what this number means? I assure you that it will be clear, if you read this page through!　<span style="float: right;">--<a href="http://swatmac.info/?p=942">日本語解説 at sw@mac.info</a></span></p>

        <h3>Introduction</h3>

<p>RANS is a library, an implementation of an Abstract Numeration System (ANS) on a regular language.</br>
RANS's concept is very simple, just calculates the number from the given string on a regular language. In other words,
<ul>
  <li>RANS provides the minimal perfect hash function that maps string to positive integer.</li>
  <li>RANS provides the 'val' that is the bijective function (one-to-one correspondence) from N onto a language.</li>
  <li>　　 and 'rep' is the inverse function of 'val'.</li>
  <li>RANS makes the set of acceptable string totally ordered by the <a href="http://en.wikipedia.org/wiki/Lexicographical_order#Ordering_of_sequences_of_various_lengths">Lexicographic order</a>.</li>
</ul>
Example: Let a regular language L = { "", "a", "b", "c", "aa", "ab", "ac", "bb", "cc", "aaa", ... }, val: L -> N, and inverse function rep: N -> L. then following equations holds:
</p>
<pre><code class="prettyprint lang-sh"> val("")==0, rep(2)=="b", val("c")==3, rep(5)=="ab", val("aaa")=9
</code></pre>
<p>These definition and aspect as stated above is basic concept of an ANS.
</p>

<h3>Install and Try RANS</h3>
<p>RANS's main code is contained in actually one header file: <a href="http://github.com/sinya8282/RANS/blob/master/rans.hpp">rans.hpp</a></br>
If you wants to use RANS as a C++ library, check this page <a href="api.html">RANS C++ API Documentation</a>.</br></br>

In this page, I just explain how to use RANS's command line tool 'rans'.</br>
Firstly, you should checkout source code, and build it. (Depends on: gflags, gtest, gmp)
</p>
<pre><code class="prettyprint lang-sh">% git clone "http://sinya8282@github.com/sinya8282/RANS.git"
% cd RANS
% make check    # can be skipped
% make install  # install header file (rans.hpp) & RANS cui (rans)
% # rehash
% rans
RANS command line tool.
Usage: rans REGEX [Flags ...]
You can check RANS extended regular expression syntax via '--syntax' option.
</code></pre>

<p>You can also install via Homebrew if you using Mac OS X:</p>
<pre><code class="prettyprint lang-sh">% brew tap sinya8282/rans
% brew install --HEAD rans
</code></pre>

<p>Now, you can try 'rans'.</p>
<pre><code class="prettyprint lang-sh">% rans "a*(c*|b*)" --text aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
1936
% rans "a*(c*|b*)" --value 2382
aaaaaaaaaccccccccccccccccccccccccccccccccccccccc
% # you can use a convesion via pipe, as well.
% echo a aa aaa | rans 'a*' --tovalue
1
2
3
% echo 1 2 3 | rans 'a*'
a
aa
aaa
</code></pre>

<h3>Regular Expression Syntax</h3>

<p>You could check the syntax via --syntax option</p>
<pre><code class="prettyprint lang-sh">% rans --syntax
RANS "simplified" extended regular expression syntax:
  regex      ::= union* EOP
  union      ::= concat ('|' concat)*
  concat     ::= repetition+
  repetition ::= atom quantifier*
  quantifier ::= [*+?] | '{' (\d+ | \d* ',' \d* ) '}'
  atom       ::= literal | dot | charclass | '(' union ')'
                 utf8char # optional (--utf8)
  charclass  ::= '[' ']'? [^]]* ']'
  literal    ::= [^*+?[\]|]
  dot        ::= '.'
  utf8char   ::= [\x00-\x7f] | [\xC0-\xDF][\x80-\xBF]
               | [\xE0-\xEF][\x80-\xBF]{2}
               | [\xF0-\xF7][\x80-\xBF]{3}
</code></pre>

<p>NOTE: the dot symbol '<b>.</b>' matchs any 1byte character, including the newline symbol '<b>\n</b>'.</p>

<h3>Use RANS as a Text Converter</h3>

I often see this question in the web, 「How to convert Hexadecimal and Octal to Binary?」. RANS provides a general solution of this problem(base-conversion). It's simple, calculates the val() of the given text on the language which represents a base-k numeration system, and then calculates the rep() on the language which represents a base-l numeration system.</br></br>

Example (Hexadecimal-Octal conversion):
<pre><code class="prettyprint lang-sh">% # Firstly, convert the decimal representation to the octal representation.
% rans '0|[1-7][0-7]*' --text 31723501261722172350012617220172317235012617221501261722172350126172217235012617221
366279202153417409243738390844334144022596873428737191758601997964469280401
% # OK. next, convert this value to the hexadecimal representation of itself.
% rans '0|[1-9A-F][0-9A-F]*' --value 366279202153417409243738390844334144022596873428737191758601997964469280401
CF4E82B1E91E9D00AC7A40F4CF4E82B1E91A0AC7A47A74158F48F4E82B1E91
% # You can do that more directly using --from and --into options.
% rans --from '0|[1-7][0-7]*' --into '0|[1-9A-F][0-9A-F]' --text 31723501261722172350012617220172317235012617221501261722172350126172217235012617221
CF4E82B1E91E9D00AC7A40F4CF4E82B1E91A0AC7A47A74158F48F4E82B1E91
</code></pre>
</br>

<h3>Use RANS as a Compressor</h3>

<p>RANS's concept is very simple, but more flexible than that. <br>
You might think 「So what? Is there any practical usage?」</br>
<font color="#F2F2F2">(｀・ω・´) イイぜっ!! 見せてやるっ！正規表現の無限の可能性をよっ！</font>
</br>
Okay, here I give the more practical example about "compression". That is, http-url.</p>

<p><a href="http://www.ietf.org/rfc/rfc2396.txt">Formal http-url syntax</a> can be defined by the (POSIX extended) regular expression.
In this example, we consider the more simple regular expression of http-url, such as:
</p>

<pre><code>[a-z][\x2b\x2d\x2e0-9a-z]*:(//(([\x2d\x2e0-9_a-z~]|%[0-9a-f][0-9a-f]|[!\x24&-,:;=])*@)?(\x5b(([0-9a-f]{1,4}:){6}([0-9a-f]{1,4}:[0-9a-f]{1,4}|(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5]))|::([0-9a-f]{1,4}:){5}([0-9a-f]{1,4}:[0-9a-f]{1,4}|(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5]))|([0-9a-f]{1,4})?::([0-9a-f]{1,4}:){4}([0-9a-f]{1,4}:[0-9a-f]{1,4}|(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5]))|(([0-9a-f]{1,4}:)?[0-9a-f]{1,4})?::([0-9a-f]{1,4}:){3}([0-9a-f]{1,4}:[0-9a-f]{1,4}|(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5]))|(([0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::([0-9a-f]{1,4}:){2}([0-9a-f]{1,4}:[0-9a-f]{1,4}|(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5]))|(([0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:([0-9a-f]{1,4}:[0-9a-f]{1,4}|(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5]))|(([0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::([0-9a-f]{1,4}:[0-9a-f]{1,4}|(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5]))|(([0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(([0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::|v[0-9a-f]+\x2e[!\x24&-\x2e0-;=_a-z~]+)\x5d|(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\x2e(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])|([\x2d\x2e0-9_a-z~]|%[0-9a-f][0-9a-f]|[!\x24&-,;=])*)(:\d*)?(/([\x2d\x2e0-9_a-z~]|%[0-9a-f][0-9a-f]|[!\x24&-,:;=@])*)*|/(([\x2d\x2e0-9_a-z~]|%[0-9a-f][0-9a-f]|[!\x24&-,:;=@])+(/([\x2d\x2e0-9_a-z~]|%[0-9a-f][0-9a-f]|[!\x24&-,:;=@])*)*)?|([\x2d\x2e0-9_a-z~]|%[0-9a-f][0-9a-f]|[!\x24&-,:;=@])+(/([\x2d\x2e0-9_a-z~]|%[0-9a-f][0-9a-f]|[!\x24&-,:;=@])*)*)?(\x3f([\x2d\x2e0-9_a-z~]|%[0-9a-f][0-9a-f]|[!\x24&-,/:;=\x3f@])*)?(\x23([\x2d\x2e0-9_a-z~]|%[0-9a-f][0-9a-f]|[!\x24&-,/:;=\x3f@])*)?
</code></pre>

<p>This is hairy, pathological expression. The minimal consistent DFA has 180 states in additional. I generated one graph of this DFA via --dfa option (also this expression is contained in the repository: test/<a href="http://github.com/sinya8282/RANS/blob/master/test/uri.rfc3986.regex">uri.rfc3986.regex</a>).</p>
<pre><code class="prettyprint lang-sh"> % rans -f test/uri.rfc3968.regex --dfa | dot -Tpdf -o http-url.pdf </code></pre>
<p>The DFA has many transition rules as shown below. <a href="images/uri.rfc3986.pdf" target="_blank"><img src="images/uri.rfc3986.png"></a></p>
<p>

<p>Okay, http-url is definable by the regular expression, recognizable by the DFA, and hence enumerable with RANS.</br>
Let's try to get the number of this page's http-url: <a href="http://sinya8282.github.com/RANS/">http://sinya8282.github.com/RANS/</a>
</p>
<pre><code class="prettyprint lang-sh">% # -i option means 'ignore case'
% rans -i -f test/uri.rfc3986.regex --text "http://sinya8282.github.com/RANS/"
36858570256415121325678741627137383137485170961739808804878081
% rans -i -f test/uri.rfc3986.regex --value 
http://sinya8282.github.com/RANS/
% # Do you remember seeing that number somewhere before ?
</code></pre>

<p>and the data size of this url and the correspondence number is 33 and 26 (Bytes). You can make sure it by --compress/--decompress options.</p>
<pre><code class="prettyprint lang-sh">% echo -n "http://sinya8282.github.com/RANS/" > url
% rans -i -f test/uri.rfc3986.regex --compress url
% ls -lh url url.rans   # compressed file is created with '.rans' extension
-rw-r--r--  1 ryoma  staff    33B Mar  3 20:15 url
-rw-r--r--  1 ryoma  staff    26B Mar  3 20:15 url.rans
% rm url
% rans -f test/uri.rfc3986.regex --decompress url.rans
% cat url
http://sinya8282.github.com/RANS/
</code></pre>

<p>That is, RANS can gives us the "compact" representation of the input string on the assumption that we know the well-defined language (or scheme, regular expression) of the set of input strings. As http-url, there are many scheme based languages in the real world.</br></br>
So what do you use it for? Dispose of the matter at YOUR discretion.</p>

<p>You can see more usage via --helpshort option</p>

<h4>Performance: Does RANS works well on a Big Data?</h4>

<p>No, I don't think so (at least for current implementation).</br>
Because the larger the number becomes, the more operation and space will be needed in multiprecision integer multiplication (RANS uses GMP C++ class interface).</br></br>

Suppose an each multiplication performs in constant time, val() runs in time O(n*|D|^2) and rep() runs in time O(n log n * |D|^3) where n is the length of the source text and |D| denotes the size of the DFA.
</p>

<h3>Do you become interested in RANS?</br>and how it works internally?</h3>

<p>You could check the <a href="https://github.com/sinya8282/RANS">source code in the repository</a>!</br>
Also if you interested in an ANS, more mathematical aspects, see Berthé and Rigo's work <a href="http://www.cambridge.org/gb/knowledge/isbn/item2708037">"Combinatorics, Automata and Number Theory"</a> or their lecture notes.</p>

<h3>Author</h3>
<p>Ryoma Sin'ya (<a href="http://twitter.com/sinya8282">@sinya8282</a>)</p>
<p>Feature suggestions and bug reports are always welcome via <a href="http://github.com/sinya8282/RANS/issues">GitHub issues</a> or <a href="http://twitter.com/sinya8282">Twitter</a>.</p>
<h3>Acknowledgment</h3>
<ul>
  <li>Special thanks to Michel Rigo who is one of the originators of ANS, and gave me helpful comments.</li>
</ul>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">RANS maintained by <a href="https://github.com/sinya8282">sinya8282</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
  </body>
</html>
